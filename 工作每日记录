Maven项目的目录骨架约定

MavenProjectRoot(项目根目录)
   |----src
   |     |----main
   |     |         |----java ——存放项目的.java文件
   |     |         |----resources ——存放项目资源文件，如spring, hibernate配置文件
   |     |----test
   |     |         |----java ——存放所有测试.java文件，如JUnit测试类
   |     |         |----resources ——存放项目资源文件，如spring, hibernate配置文件
   |----target ——项目输出位置
   |----pom.xml ----用于标识该项目是一个Maven项目

POM文件：
groupId, artifactId version.//packaging
groupId定义属于哪个组
artifactId定义项目在组中唯一的ID
version制定了xxxx项目当前的版本--SNAPSHOT意为项目还处于开发中，不稳定版本
//packaging

mvn -v
     compile
     test
     package 打包成jar
     clean 删除target
     install 安装jar包到本地仓库中

创建目录的两种方式：
1.mvn archetype:generate
2.mvn archetype: -DgroupId = xxx -DartifactId = xxx -Dversion = xxx -Dpackage = xxx;

maven生命周期
clean 清理项目
default 构建项目
site 生成项目站点

execution plugins 用否？
<excutions> <excutions>
  <execution>
    <phase>package</phase>
    <goals>
      <goal>run</goal>
    </goals>
  </execution>

<packaging> --jar war pom zip
<name></name>
<url></url>
<description></description>
<developers></developers>
<licenses></licenses>
<organization></organization>

<dependencies>
  <dependency>
    <groupId></groupId>
    <artifactID></artifactId>
    <version></version>
    <type></type>
    <scope>test</scope>//六种 compile为默认  provided run
     test system imort
    <optional></optional>//默认为false 可依赖
    <exclusions>坐标</exclusions>防止传递依赖 排除依赖
    例：
    <exclusions>
      <exclusions>
          <groupId></groupId>
        <artifactId></artifactId>
      </exclusions>
    </exclusions>


<parent></parent> 继承pom
<modules></modules> 指定多个模块一起进行编译

依赖以最短路径为主：1.A-B-C-X(jar) 2.A-D-X(jar) 会走第二条路

聚合 一起install：
<packaging>pom</packaging>
<modules>
  <moudle> maven名字</moudle>
  <moudle> maven名字</moudle>
  <moudle> maven名字</moudle>
<module>
修改setting.xml文件 可使默认jdk 变为你想要的（3-8）。


问题：
确认：
代码中：

<groupId>com.alibaba</groupId>
<artifactId>fastjson</artifactId>

<groupId>commons-codec</groupId>
<artifactId>commons-codec</artifactId>
<version>1.4</version>
commons-codec-1.4.jar
会从中央仓库下载吗？

<packaging> --jar war pom zip 区别

本地仓库如何看？
~/.m2/repository

Spring看的方向：
springboot springmvc springcloud

IOC控制反转 bean装配 AOP面向切面 AspectJ

Feb.27:
Spring 注入：
  -设置注入?写法
  -构造注入?
xml文件写在哪里？

JUnit 测试？
IntelliJ IDE 基础使用。
Xml方式还是@。。。commnent也要
@RunWith

Bean配置项 作用域 生命周期 自动装配 Resources&ResourceLoader
Bean ： Id
        Class//必须的
        Scope
        Constructor arguments
        Properties
        Autowiring modelVersion
        lazy-initialization modelVersion

作用域： singleton 只存在一份
        prototype 每次都会创建的
        request：http创建一个实例并仅在当前request内有效
        session：
        global session

Aware?

自动装配(Autowiring) No, byname, byType, Constructor

Resources
  --UrlResource
  --ClassPathResource
  --FileSystemResource
  --ServletContextResource
  --InputStreamResource
  --ByteArrayResource

ResourceLoader

@Configuration @Bean @Import @DependsOn
@Component
@Repository @Service @Controller

类的自动检测及Bean的注册
Spring可以自动检测类并注册Bean到ApplicationContext中

<context:component-scan base-package="org.example"> 定义哪个包下面
使用过滤器进行自定义扫描
<context:include-filter type = "regex">
<context:exclude-filter type = "annotation">

定义Bean

Autowired 注解
Spring BeanPostProcessor处理，不能再自己BeanPostProcessor 或 BeanFactoryPostProcessor
类型应用这些注解

@Qualifer注解缩小范围 适用于fields， constructors， multi-argument methods

@Bean 标识一个用于配置和初始化一个由SpringIoC容器管理的新对象的方法
@Configuration配置文件

CustomAutowireConfigurer

JSR-250@Resource
@PostConstruct
@PreDestory

feb.28
Mybatis 的 SqlSession
作用 ：
  1.向SQL语句传入参数
  2.执行SQL语句
  3.获取执行SQL语句的结果
  4.事务的控制

public class DBAccess {
  public SqlSession getSqlSession() throws IOException {
      ///通过配置文件获取数据库连接信息
    Reader reader = Resources.getResourceAsReader("com/imooc/config/Configuration.xml");
      //通过配置信息构建一个SqlSessionFactory
      SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
      //通过sqlSessionFactory打开一个数据库会话
      SqlSession sqlSession = sqlSessionFactory.openSession();
      return sqlSession;
  }
}

SQL基本配置与执行
MessageDao.java
public class MessageDao {
  public List<Message> queryMessageList(String command, String description) {
    DBAccess dbAccess = new DBAccess();
    List<Message> messageList = new ArrayList<Message>();要先配好映射关系
    SqlSession sqlSession = null;
    try {
      sqlSession = dbAccess.getSqlSession();
      //通过sqlSession执行SQL语句
      sqlSession.selectList("queryMessageList"); --MessageDao.xml 中的id
      //messageList = sqlSession.selectList("queryMessageList");
      sqlSession.selectList("Message.queryMessageList"); 通过.来加namespace
    } catch (IOException e) {
      //TODO Auto-generated catch block
      e.printStackTrace();
    } finally {
      if(sqlSession != null) {
        sqlSession.close();
      }
    }
    return messageList;
  }
}
Message.xml
通过<mapper namespace = "Message"> namespace 加以区别

代替jdbc
动态sql拼接
OGNL表达式（单独） EL表达式
Mybatis OGNL表达式
String与基本数据类型 _parameter
自定义类型(Message) 属性名(command)
集合                数组：array
                    List:list
                    Map:_parameter
操作符  java常用操作符 + 特有的操作符 and ,or ,mod ,in ,not in

从集合中取出一条数据    数组： array[索引](String[])
                            array[索引].属性名(Message[])
                    List： list[索引](List<String>)
                           list[索引].属性名(List<Message>)
                    Map:   _parameter.key(Map<String, Message>)
                            key.属性名(Map<String, Message>)
利用 foreach 标签    <foreach collection = "array" index = "i" item = "item">
从集合中取出数据       数组
                    List     i:索引(下标)            item
                    Map      i: key                item.属性名
&quot;&quot;双引号
&amp;&amp; --- && 或者直接写and
COMMAND = #{command} ---  ？

使用Maven 在pom.xml中加入<dependency>
<dependency>
  <groupId>org.mybatis</groupId>
  <artifactId>mybatis-spring</artifactId>
  <version>x.x.x</version>
</dependency>



log4j调试动态no

Spring MVC
Front Controller
  DispatcherServlet(前段控制器)
Controller
  HandlerAdapter
HandlerInterceptor(拦截器)。

HandlerMapping()
1. Help DispatcherServlet to get the right controller
2. Wrap controller with HandlerInterceptor

HandlerExecutionChain

preHandle ---> Controller method ---> postHandle ---> afterCompletion

ModelAndView

ViewResolver(告诉DispatcherServlet哪个视图对象)

View

//mvc-dispatcher-servlet.xml
<context:annotation-config/> 激活 标注bean 申明

<mac:annotation-driven/>



问题：classPath具体是指从哪里到哪里。

项目源代码问题：
pay-cashier:
10 pom 为了一起安装子的pom？
20-35行 怎么定义的？ lion pigeon cat zebra repo env
${lion.client.version} 表达式
102-135
181-217 jakarta? 这些包都是从setting.xml设定的中央仓库直接下载的是吗？
dependencyManagement的目的就是为了导入前面property的版本？ 所以如果version数字手打，就不需要是吗？
340 为什么pay-cashier没有source文件，但build里面还是设置了。
343 不用${basedir}/src/main/resources
350 true?
358 configuration 里面的设置具体不一样？（again）
416 distributionManagement 用于让pom执行deploy功能？ 具体内容。

pay-cashier-service:
15 war包？
124 parent已经用了，为什么还要再写一遍？
247 profiles 的使用。
具体内部code 怎么看？

Spring版本号？是否为自己的？
march 1
ORM：对象关系映射（Object Relation Mapping）
properties配置加载
environment环境配置
settings参数设置配置
typeAliases别名设置
mapper映射加载

查询数据
-- 映射配置：sql片段
-- 映射配置： select配置
    --特殊配置：字段和属性不一致时resultMap配置？
Mybatis 开发环境搭建顺序：
1.mybatis配置
mybatis.xml主配置文件
2.SqlSessionFactorBuilder
3.1，2结合成SqlSessionFactory
4.SqlSession
SQL 语句已经提前配置到Mapper.xml中 DataBase 交换数据
SQL 输出结果器
//一定要一一对应嘛？

问题：
DAO？？？

通过Java的而不是XML定义bean，比如
@Configuration @Bean @Import, @DependsOn
@Components是一个通用注解，可用于任何bean
@Repository， @ Service, @Controller 更有针对性的注释
---@Repository通常用于注解DAO类， 即持久层
---@Service通常用于注解Service类， 即服务层
---@controller通常用于Controller类，即控制层(MVC)
Spring Autowired:

类的自动检测及Bean的注册：
Spring可以自动检测类并注册Bean 到 ApplicationContext中

spring-config.xml 文件中
<context:annotation-config/>仅会查找在同一个applicatcontext中的bean注释

<context:component-scan base-package = "org.example"/>扫描这个包下的所有类，用了这个不用前面的了
使用过滤器：
<beans>
  <context:component-scan base-package = "org.example">
    <context:include-filter type = "regex"
              expression =".*Stub.*Repository"/>
    <context:exclude-filter type = "annotation"
              expression = "org.springframework.stereotype.Repository"/>//所有用Repository注解的类
  </context:component - scan>
</beans>

有annotation assignable aspectj regex custom
例如：
@Service("myMovieLister")  这里myMovieLister就是id
public class SimpleMovieLister {
  //....
}
@Respository   没指定的话就自动id取首字母小写movieFinderImpl
public class MovieFinderImpl implements MovieFinder {
  //....
}
如果要自定义命名规则，则要包含如下：
<beans>
  <context:component-scan base-package = "org.example"
        name-generator = "org.example.MyNameGenerator" />
</beans>
作用域（Scope）
例：
@Scope("prototype")
@Respository
public class MovieFinderImpl implements MovieFinder {
  // ....
}

自定义scope默认值
<beans>
  <context:component-scan base-package = "org.example"
        scope-generator = "org.example.MyScopeGenerator" />
</beans>

代理方式（略 4-1）

@Required注解适用于bean属性的setter方法
这个注解仅仅表示，受影响的bean属性必须在配置时被填充，通过在bean定义或通过自动装配一个明确d额属性值

@Autowired注解为传统的setter方法 -----其实就是另一个方面来说是注入直接，getBean内部东西
 也可以用在构造器或成员变量

 @Autowired 注解那些众所周知的解析依赖性接口： BeanFactory， ApplicationContext, Environment, ResourceLoader
 ApplicationEventPublisher, MessageSource

 @Autowired 会把所有子类都打包
 用@order可排序 BeanImplOne

 @Qualifer 用于缩小范围
 例@Autowired
   @qualifer("指定id!")


  Spring 结合My Batis部分：
  <!--创建一个sql会话工厂bean，指定数据源 -->
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
    <!-- 1指定数据源 -->
    <property name="dataSource" ref="jdbcDataSource" />
    <!-- 2类型别名包，默认引入com.zhangguo.Spring61.entities下的所有类 -->
    <property name="typeAliasesPackage" value="com.zhangguo.Spring61.entities"></property>
    <!-- 3指定sql映射xml文件的路径 -->
    <property name="mapperLocations"
        value="classpath:com/zhangguo/Spring61/mapping/*Mapper.xml"></property>
</bean>

tomap grouping by

grouping by 返回key value
reduce reducing

读书会重点概括：
是否和spring功能有些类似 action class method/action

lambda表达式概述：
Every thing is object. all code associated with classes and objects.
定义， 写法为啥， 内容，

第八章：
匿名类 很繁琐 ，Lambda 表达式可读性更好。比如Collection.sort(abc, new comparator());不用override 这么写了直接用
匿名类中，this是本身。匿名类可以屏蔽包含类的变量。 int num 问题： 坏处用lambda表达式外面定义过了里面就不行

int num=10;
    Runnable runnable=() -> {
        int num=5;//报错 Lambda expression's local variable num cannot redeclare another local variable defined in an enclosing scope.
        System.out.println(num);
    };

String api
https://www.jianshu.com/p/d5df677c7a99

Lambda intface 里面多人 不知道是哪个，具体要指定问题：
doSomething((Runnable) () ->System.out.println("identity who?"));
doSomething((Task) () ->System.out.println("identity who?"));

调试：
不好处： Lambda表达式没有名字， 栈跟踪时报错是，系统会随便给你一个名字。

第九章：
Java8中的默认方法可以让类自动地继承接口的一个默认实现。
就是接口中添加默认方法，实现他的类不用做任何修改，如果需要可以直接调用。

Java8中抽象类与抽象接口的区别
1.一个类只能继承一个抽象类，但可以实现多个接口。（原来不就是这样的嘛？）
2.一个抽象类可以通过实例变量保存一个通用状态，而接口不可以有实例变量。

默认方法的冲突问题，先要明确几个原则： interface A 和 interface B 都有hello（）这一个默认方法
1.类中的方法优先级最高。
2.第1条无法判断，那么子接口的优先级高于任何声明为默认方法的优先级。
3.若前两条还是无法判断，继承多个接口的类必须通过显示覆和调用期望的方法，显示地选择哪一个默认方法的实现

10-12章；




Spring MVC配置：
主要是WEB-INF目录下： dispatcher-servlet.xml文件




Spring MVC数据绑定


Tomcat---是一个WEB容器，JavaEE程序可以在此运行。 ----servlet的解析

git---是一款免费、开源的分布式版本控制系统
特点，可以有效、高速的处理从很小到非常大的项目的版本管理

git常用命令：
1、 切换分支：git checkout 分支名
2. 拉取：git pull
3. 提交 git push


In previous note MyBatis Basic, we get SqlSessionFactory by SqlSessionFactoryBuilder:

String resource = "path/to/mybatis-config.xml";
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

But in MyBatis-Spring xml, bean SqlSessionFactory is created by SqlSessionFactoryBean:

<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource" /> <!-- Obliged -->
    <!-- Indicate location of mapper files where exists mysql statements -->
    <property name="mapperLocations" value="classpath*:/mybatis/*Mapper.xml"/>
    <!-- Indicate mybatis config files where exists typeAliases, settings, etc -->
    <property name="configLocation" value="classpath:/mybatis/mybatis-config.xml"/>
</bean>

<!-- In java code, it does the following step to create SqlSessionFactory
SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
SqlSessionFactory sessionFactory = factoryBean.getObject();
-->

http://dongchuan.github.io/mybatis/2016/04/18/MyBatis-With-Spring.html


!!!!!!!!
http://hmkcode.com/mybatis-spring-xml-annotation-mapper/
!!!!!


搭建spring + mybatis 查询修改等功能 思路：
1.建立maven工程 设置好pom文件（jar包 包括 MySQL， spring + mybatis）
2.配置Spring-config.xml文件（定义datasource（数据库）， sqlSessionFactory， 和
定义Mapper(MyBatis-config.xml)-->有两种方式一种是xml，一种是annotation）
3.直接在Interface.java中定义好sql的方式(用spring 来生成bean)
4.外面封一层，防止被直接浏览

用注解来简化xml配置的时候,@Param注解的作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中
我们先来看Mapper接口中的@Select方法

package Mapper;

public interface Mapper {

@Select("select s_id id,s_name name,class_id classid from student where  s_name= #{aaaa} and class_id = #{bbbb}")
    public Student select(@Param("aaaa") String name,@Param("bbbb")int class_id);

@Delete......

@Insert......

}


springMVC 学习概要
1. web.xml 配置 spring dispatchservlet ,比如为:mvc-dispatcher
2. mvc-dispatcher-servlet.xml 文件配置
3. spring applicationContext.XML文件配置(与数据库相关，与mybatis sqlSessionFaction 整合，扫描所有mybatis mapper 文件等.)
4. 编写controller 类
5. 编写页面代码jsp.

AOP的实现方式：
预编译
--aspectj
运行期动态代理（SpringAOP， JbossAOP）


jar包加载自动；

SpringMVC 大纲：
Request_mapping；
RequestPamram注解
RequestHeader注解
CookieValue注解
模型数据---ModelAndView 或 Map 或 SessionAttribute ModelAttribute

Request_mapping， Rest，处理模型数据， 数据绑定及表单标签， 转换器和格式化， 验证器(JSR303)，
文件上传，文件下载，整合Ckeditor且实现图片上传。

http请求 进到提供的服务器里面 controller 怎么拿到参数 怎么返回 输出html json 序列号数据


SpringMVC 结合任务二 思路：
1.首先建表。
2.搭建Maven工程， 导入对应包。
3.配置web.xml文件，springmvc的前端控制器，拦截所有请求(DispatcherServlet).
4.配置DispatcherServlet文件(Spring-servlet或dispatcherServlet-servlet.xml)文件也就是springMVC
配置文件的设置。(web.xml指向springmvc.xml位置)
-----以上为独立的spring mvc配置----------
-----下面是spring+mybatis配置相对比较独立-----
5.完成spring 配置文件的设置，把mybatis配置和spring配置可写在一起，完成bean的设置。
6以下步骤重复任务二

三四周知识点整理：
pigeon：

appcontext-client.xml serialize 序列化方法，但是序列结果往往是一样的。只是效率不一样，
为了拿别人的方法数据等
appcontext-server.xml 为了配置进来让别人使用实现
entry 前面是key 后面是 value 为了能给他人取，
下面是bean注入
Repository 里面一般是业务操作实现。
serialVersionUID = 1L;要设置一下。 没什么用其实（BaseRequest.java）

zebra：------>Mybatis 封了一层 可控 查询可以异步(没用) 分库。
主库---只用来写， 从库只用来读 dao层， GroupDataSource---读，写

lion：业务平台， zookip 用于配置参数，api提供， 不需要重启系统就可以完成编译。
cat（平台监控）：service 被调用了多少次，日志，业务大盘---曲线图problem出现在哪里。（黑线前天，蓝色今天）轮询 ，访问量比较
是否正常.
主动配置 transcation 默认， 发布一坟台机器（尤其是自己改过的代码，至少隔5分钟再发另一台）。
catutil.logmetremcount支付回调， 自己打点查看的。

logscan:(日志) 监控。收集日志，打点

支付中心原理图：
pay-mapi-web(主要是调用第三方app) pay-cashier-web(h5平台）外包一层，其实调用pay-cashier-service
和 pay-gate-service两层东西

pay-gate-service 具体统筹配置，分流给到底是支付宝，微信还是其他的类型。

支付回调有两种，一种是主动回调，一种是被动回调。主动回调：我们调第三方消息，查看支付状态，
被动回调，第三方来调我们的接口，url，来确定状态。

1.退款，（我们这里）创单
2.调第三方接口
3.更新退款信息状态
4.查退款结果，做最后的update

三四周任务具体计划：
1.pigeon，zebra 写一个简单接口
2.lion，cat,logscan查看
3.看一下cat的具体文档
4.git的分支策略。
5.看一下中间模块的各调用。
6。database表 1.具体表内容，干嘛的 2.分析表之间的关系  结合1、2制作出ER图 3.

看代码：
快捷键设置：类查找，实现，调用，搜索。
https://www.cnblogs.com/gisblogs/p/7091194.html
搜索全部内容：shift两下；
command + N 自动生成get set等方法
control + O 重写父类方法
option + 上 连续选中代码
command + O 查找class（类）
command + option + O 查找方法
command + shift + delete 查看最后一次编辑的地方
command + B 或者 左键 进入光标所在的方法/变量接口或定义处
command + option + B 跳转到方法实现处
control + shift + B 跳转到类型声明处
command + Y 快速打开光标所在方法、类的定义
command + U 前往当前光标所在方法的父类的方法 / 接口定义
command + shift + F 全project搜索
如何看：
api-service ---> prepayorderIml(具体实现一步一步往下看,一个方法一个方法看)
order--->resposity--->CreatePreOrderModule

verification较验， buildBeforePrePayContext构建上下文
IBeforePrePayModule实现 find Usages；


git 学习：
创建
touch README.md
touch .gitignore
git init
git status
git add . (或者你具体想要提交的文件名)
git commit -am 'first commit init project' ///git commit -m "first commit"
git remote add origin git@git.intra.im:quanju.gu/test.git
git branch
git push -u origin master
git pull
git push -u -f origin master (强制推送)
git branch -r 看远处分支
分支开发主干发布
git checkout -b v1.0 origin/master (切换到新的分支)
git branch
git push origin HEAD -u

发生冲突：
git pull
git diff可查看哪里不一样
进去可以看哪里
再来一次提交就可以了。

git log 查看之前的修改
复制commit id
git reset --hard id 退回代码
git reflog 查看当前版本的版本号
---pull就是回到过去之前的
git reset --hard id 回到未来

建立里程碑：
release 在界面；

分支开发：
创建分支，切到分支上
merge

Git global setup
git config --global user.name "quanju.gu"
git config --global user.email "quanju.gu@owitho.com"

Create a new repository
git clone git@git.intra.im:quanju.gu/test.git
cd test
touch README.md
git add README.md
git commit -m "add README"
git push -u origin master

Existing folder
cd existing_folder
git init
git remote add origin git@git.intra.im:quanju.gu/test.git
git add .
git commit -m "Initial commit"
git push -u origin master

Existing Git repository
cd existing_repo
git remote rename origin old-origin
git remote add origin git@git.intra.im:quanju.gu/test.git
git push -u origin --all
git push -u origin --tags





是否需要安装依赖？

yum -y install mysql-serialVersionUID

rpm -qa| grep mysql-server (看是否安装成功)

/etc/my.cnf默认文件是否在

vim /etc/my.cnf
添加配置，在【mysqld】节点下添加：
default-character-set = utf8       5.1
character-set-server = utf8        5.5
:wq

mysql安装
chkconfig mysqld on
chkconfig --list mysqld

防火墙配置？


mysql服务启动
service mysqld start 或 /etc/rc.d/init.d/mysqld start

mysql初始化环境配置
mysql -u root -p 密码root

查看当前mysql的用户
select user,host,password from mysql.user
修改root密码
set password for root@localhost=password('youpassword');
(3)exit
删除匿名用户
delete from mysql.user where user = '';
刷新，使以上操作生效：flush privileges

插入mysql新用户
insert into mysql.user(Host,User,Password) values ("localhsot", "yourusername", password("yourpassword"));

创建新的database
CREATE DATEBASE `MALLLL`;

10 本地用户赋予所有权限

grant all privileges on mmall.* to yourusername@localhost identified by 'yourpassword'

11.给账号开通外网所有权限
grant all privileges on mmall.* to yourusername@'%' identified by 'yourpassword'

12;
grant select, insert on mmall.* to yourusername@'192.11.11.11' identified by 'yourpassword'

ifconfig 查看mysql地址；

常用命令：
sudo service mysqld start;
sudo service mysqld stop;
sudo service mysqld restart;


业务方：(流程图图上红色的都是业务方。)
一：
跳转参数 id jump_params
AUTO_INCREMENT=81670

二：
32 64？自定义的2的多少次方
version：乐观锁
五：
sub_step_id 可能有多个步骤所以用
context_info
六：
高4位主状态，低5位子状态？
enable_pay limit_pay 允许支付渠道为啥用varchar？（暂时没用）
七：risk（不用）
八：token（不用）
十：biz_config： json1，2，3？？ （作为json 一个数组来传送）
十二 ls_pct_payorder：旧表？？？？？（是的，ls_pct_payorder为新表， ls_paycenter_order为旧表）
context_params（备用参数以便以后添加参数来使用）
ls_refund_order:refund_to_credit;（退款到余额里面）

日志编程是否要看一下

interface ---> implements --> 具体 疑问？
public class OrderQueryResp extends BaseResp implements Serializable???
repository
baseRequest?

cat:logview 需要更多埋点？
transcation event heartbeat

看码心得：
首先先要定义一个接口， 接口内部定义好需要的方法
例：
PrepayOrderQueryService.java
public interface PrepayOrderQueryService {


    /**
     * 查询订单信息
     *
     * @param orderQueryReq
     * @return
     */
    OrderQueryResp queryOrderDetail(OrderQueryReq orderQueryReq);
}

api ---->   serviceImpl(module stratgy, ocuppy)  --->reposity ---> Mapper ---->Xml  ----->DB
参数校验，逻辑service（BaseService）插表DB， 第三方， 更新DB，
拼装返回。

PO--->表
BO--->新综合
DTO--->要传给数据接受对方的表

原来只有一张表                    预付两张表
order只能1对1；        prepayOrder, payOrder为了能做到1对n

最重要的两张表： ls_pct_prepayorder; ls_pct_payorder;
旧表：ls_paycenter_order;

订单查询：（已完成）结构：
PrepayOrderQueryService.java-->PayOrderQueryService.java--->PayOrderNewQueryRepository.java--->PayOrderNewMapper.java--->PayOrderNewMapper.xml


问题：（PaymentResultCode.class）
public static PaymentResultCode getInstance(int code) {
      PaymentResultCode[] var1 = values();
      int var2 = var1.length;

      for(int var3 = 0; var3 < var2; ++var3) {
          PaymentResultCode paymentResultCode = var1[var3];
          if(paymentResultCode.getCode() == code) {
              return paymentResultCode;
          }
      }

      return null;
  }

  为什么是values();
  PaymentResultCode[] var1 = PaymentResultCode.values();

  <insert id="insert" parameterType="com.lingshou.pay.cashier.po.PayOrderPO">
      <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Long">
          SELECT LAST_INSERT_ID()
      </selectKey>
      INSERT INTO LS_PayCenter_Order (
      biz_type,biz_order_id,trade_no,third_part_order_id,business_type,channel,method,pay_status,refund_status,pay_time,notify_url,return_url,user_id,total_pay_money,third_part_money,platform,pay_subject,pay_desc,expire_time,enable_pay,limit_pay,user_ip,created_by,create_time,update_time,update_by
      ) VALUES (
      #{bizType},#{bizOrderId},#{tradeNo},#{thirdPartOrderId},#{businessType},#{channel},#{method},#{payStatus},#{refundStatus},#{payTime},#{notifyUrl},#{returnUrl},#{userId},#{totalPayMoney},#{thirdPartMoney},#{platform},#{paySubject},#{payDesc},#{expireTime},#{enablePay},#{limitPay},#{userIp},#{createdBy},#{createTime},#{updateTime},#{updateBy}
      )
  </insert>

  resultType ?????


  放一下的问题：
  JSON.toJOSNString(tradeNo);

  RefundOrderReadMapper.xml 中的if部分


!!!!!!!BeforeRefundContext; refundOrderBean;
ProStatus;RefundProStatus;
IBeforeRefundModule;callBackContext
end!

RefundGateFactory.java 中为什么要用Qualifier注解？？？？？？？
RefundGeneratorForAppAli.java :
done!
51 AlipayTradeRefundRequest req = generateAlipayTradeRefundRequest(context);
ApipayClient里面的方法？

RefundRequestBeanForWxM
@XmlTransient 转译成Xml

GetPayModeController.Java?????
@CrossOrigin
@ModelAttribute
反josn数据？？？


PayGateController作用？  paychannel?
web工程能在本地跑吗？

读书会总结：
10章：
Optional类
Optional<T> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用null 表示一个值不存在，现在Optional 可以更好的表达这个概念。并且可以避免空指针异常。
常用方法：
Optional.of(T t) : 创建一个Optional 实例
Optional.empty() : 创建一个空的Optional 实例
Optional.ofNullable(T t):若t 不为null,创建Optional 实例,否则创建空实例
isPresent() : 判断是否包含值
orElse(T t) : 如果调用对象包含值，返回该值，否则返回t
orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回s 获取的值
map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty()
flatMap(Function mapper):与map 类似，要求返回值必须是Optional

11章：
CompletableFuture
Java从Java 5版本就提供了Future接口。Future对于充分利用多核处理能力是非常有益的，因为它允许一个任务在一个新的核上生成一个新的子线程，新生成的任务可以和原来的任务同时运行。原来的任务需要结果时，它可以通过get方法等待Future运行结束（生成其计算的结果值）。
Future接口的局限性

使用Future中提供的方法完成这样的操作又是另外一回事。这也是我们需要更具描述能力的特性的原因，比如下面这些。

将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。
等待Future集合中的所有任务都完成。
仅等待Future集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同一个值），并返回它的结果。
通过编程方式完成一个Future任务的执行（即以手工设定异步操作结果的方式）。
应对Future的完成事件（即当Future的完成事件发生时会收到通知，并能使用Future计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果）。

CompletableFuture 详解
一个非常有用，不过不那么精确的格言这么说：“Completable-Future对于Future的意义就像Stream之于Collection。”让我们比较一下这二者。
通过Stream你可以对一系列的操作进行流水线，通过map、filter或者其他类似的方法提供行为参数化，它可有效避免使用迭代器时总是出现模板代码。
类似地，CompletableFuture提供了像thenCompose、thenCombine、allOf这样的操作，对Future涉及的通用设计模式提供了函数式编程的细粒度控制，有助于避免使用命令式编程的模板代码。

12章：
新时间日期API
使用LocalDate、LocalTime、LocalDateTime
LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用ISO-8601日历系统
的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关
的信息
Instant 时间戳
用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算
Duration 和Period
Duration:用于计算两个“时间”间隔
Period:用于计算两个“日期”间隔
日期的操纵
TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。
TemporalAdjusters : 该类通过静态方法提供了大量的常用TemporalAdjuster 的实现。
例如获取下个周日
解析与格式化
java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：
预定义的标准格式
语言环境相关的格式
自定义的格式
时区的处理：
Java8 中加入了对时区的支持，带时区的时间为分别为：
ZonedDate、ZonedTime、ZonedDateTime
其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式
例如：Asia/Shanghai 等
ZoneId：该类中包含了所有的时区信息
getAvailableZoneIds() : 可以获取所有时区时区信息
of(id) : 用指定的时区信息获取ZoneId 对象


March 19：
上线流程整理：
命名规则：gqj_20180319_功能描述
merge request git diff 到分支。
审核过后relase版发布到线上

要反复编译的 jar包命名用 0.2.3-SNAPSHOT

上线文档 + 发邮件

问题：
@postContstruct -- BasePayGateV2Repository.java;
BasePayGateV2Repository ---toPay结束。

AppAliPayCallBackController.Java
对方来调我们/paycore/appAliPayCallBack 验证好回写支付宝。
支付宝同时给我们request 和 reponse reponse给我们回写，request给我们我们需要的参数


CreateOrderModule.Java
怎么做到一对多的。
context；

payOrderService--老的流程，只是为了老表双写，新的流程需要双写，老的流程也需要双写。

支付中心流程
业务方
点完确认支付后，都走完了，就等回调。

pay-gate-service 创支付单 做策略的分发
pay-gate-alipay-service 我们在第三方创预付单，把我们这笔订单的信息都给第三方，
但是订单还是待支付状态，这时候第三方调用我们的接口并返回我们一些参数(一些参数是我们拿的)，我们把这些参数
给到前端，前端就会把那个页面换起来。我们事情这里已经做完了。处理完后回调我们。然后我们把回调的东西给业务方就行了。

（早上13：10）
第三方回调我们，我们拿到支付结果，更新我们数据的更新，更新完通过mq给到业务方同步支付状态。




问题：

pay-cashier:
callbackserviceimpl

payOrderNewRepository
payOrderOperateRepository 有区别吗？ 重写两遍？？？
4个controller再确定一下

PayGateController--在点的一刹那进行调用。就可以选了。代码56行。

任务：
写一个controller 服务查询， 通过预付单的prepay_order_no 查出对应的biz_id和biz_type 和查出对应的pay_order_no

Maven红字处理：
cd /Users/quanjugu/.m2/repository
cd lingshou/
rm -rf pay-cashier-api/     移除

提交maven过程
clean   ----->   install   ------> deploy

git创建分支：
点进去 --->创建分支 --->命名---->提交
先下载再切分支

任务三：开发一个Spring MVC类似的小程序通过给定的pre_pay_No来获得biz_type 和 biz_order_id
并且根据pre_pay_No取到对应的payorder内的信息（多条），一对多条内容。

思路：
1.创建BizQueryReq(入参使用，成员变量prepayNo(g,s));
  创建BizQueyResp(出参使用，成员变量BizDetailDTO(g,s)自定义DTO类型表格)；
  并创建bizDetailDTO.java表格（需要拿到的参数）;
2.创建BizOrderQueryService接口（方法queryBizDetail你需要赋值到DTO表格的方法）;
3.创建BizOrderQueryServiceImpl类（实现根据入参取得表数据，得到需要PrepayOrderPO,转成bizDetailDTO）；
此处要进行Spring配置 appcontext-server.xml(pigeon).
4.创建BizOrderQueryRepository.java（提供需要得到上述对应表格的方法，需要定义Mybatis对应方法已便连接数据库）；
5.创建BizPrepayOrderReadMapper接口(定义mapper方法，和对应参数param的对象)。
6.创建BizPrepayOrderReadMapper.xml(定义mysql方法)。

到web页面定义controller，以便在网页上可以调用；
1.创建@RequestMapping 链接
2.定义返回Josn Map类型数据（@ResponseBody）
3.调用service 层中接口。导入prepayNO数据(@PathVariable)
此处一样要进行spring或许配置 appcontext-client.xml(pigeon到pigeon上获取)
4.如图上取得对应DTO表，定义ResponseUtil类生成对应Map
5.取得Map数据并返回。


问题：配置spring？peigon?(done!!!)
可以进行任意配置不影响
为何不用resultMap结果也可以对应。
因为在mybatis-configuration.xml文件中已配置 <setting name="mapUnderscoreToCamelCase" value="true"/>
所以可以自动去除下划线然后匹配上
query黑屏问题

上线流程：
1.先到gitlab上提交merge request， 然后等组长或者德龙哥审核通过
2.http://jenkins.intra.im/job/prod-pay-gate-service/ 来到先点配置检查版本是否为release。
点构建
点击下方版本是否为最新的
构建的主要目的是为了看能否编译通过，然后到lion上面配置需要配的参数。(或在二前面)
3.如果有脚本程序需提前一天和组长说让他泡一下
4.构建配置完成以后，到http://rundeck.intra.im
pay-cashier-service
prod-paychashier-web
找到配置的机子点run Job now / update
5.上cat 找到对应机号看。Problem / Event/ transcation
pay-cashier-service ---> 查看pigeon service order query 修改的接口
prod-paycashier-web     ---> paycore/gate


测试的话，用下面的
二：online环境测试账号

用支付宝和微信界面测试

删除文件
rm -rf *.iml
rm -rf .idea



2.熟悉git协作分支策略，会使用常用命令；
3.熟悉支付中心各应用模块的用途以及之间的调用关系
5.熟悉编码, 上线流程；
6.做任务

改beta
<bean id="lion" class="com.lingshou.lion.client.InitializeConfig"/>

   <bean id="ssoServiceUrl" class="java.lang.String">
       <constructor-arg value="http://localhost:8082/"/>
   </bean>

   <bean id="ssoServiceWelcomeUrl" class="java.lang.String">
       <constructor-arg value="http://localhost:8082/"/>
   </bean>


编程代码问题整理：
1.PayModeQueryResp.java uid? payModeDetailDTO.java UID?
2.PayModeQueryResp? 复用payGateResultCode
3.xml name关键字问题。
4.status = '0' 确认一下。
5.now()问题。
6.beanutils自动找命名一样的？Respository

7.PayModeDetailRepository.java 再思考一下runtimeException.
8.PayModeDetailServiceImpl Cat配置 后配

9哪一层处理createby createtime等数据
10.<!--create_time =#{createTime},--> 被我删了，在插数据的时候

!!!!!!paymodepo 里面多了一个type？ sql文件是否还可以用？？
!!!!!!版本号问题！！！！！

11.insert 删除createby 和updateby

测试问题：
进入
http://localhost:4080/services进行测试
http://172.19.24.117:4080/

payjobs:
http://172.19.24.144:4080/services

或者进入（不确定）
先发布到分支上
http://rundeck.intra.im
然后找



{"payModeDetailDTO":{""}}
测试代码：payMode
改：{"payModeManageDTO":{"id":12,"channel":44,"method":55,"name":"anglebaby","description":"weixin","status":1,"enabled":1}}
增：{"payModeManageDTO":{"channel":25,"method":32,"name":"anglebaby","description":"weixin","status":1,"enabled":1}}

测试代码：payModeConfig:
增：{"payModeManageConfigDTO":{"platform":25,"payModeId":32,"type":"1","sequence":"3","status":1}}
改：{"payModeManageConfigDTO":{"id":14,"platform":28,"payModeId":36,"type":"1","sequence":"3","status":1}}

测试代码：payModeBizConfig:
增：{"payModeManageBizConfigDTO":{"bizType":23,"payModeIds":"[1]","excludeModeIds":"[2]","isNeedConfirm":0,"serviceUrl":"http://service.owitho.com/welfare/welfare/rackOrderPayQueryService_1.0.0","status":1}}
改：{"payModeManageBizConfigDTO":{"id":4,"bizType":24,"payModeIds":"[2]","excludeModeIds":"[1]","isNeedConfirm":0,"serviceUrl":"http://service.owitho.com/welfare/rackOrderPayQueryService_1.0.0","status":1}}





UPDATE LS_Pct_Paymode
    SET channel = 13,
    method = 32,
    name = "name",
    description = "11",
    status =1,
    enabled =1,
    update_time = now()
    WHERE id = 11;

    UPDATE LS_pct_paymode SET channel = 99 WHERE id= 12;

前端：
前端框架
vue // element ui
前端构建：
webpack

前端工程化
local<--->gitlab----->jenkins----->static<---->CDN
                            ----->static path
ws

html ftl

webpack config.js 关注entry

git checkout master/release 切到master
git checkout -b demo-0330

npm run build

modules vue中引element ui中的内容

extension 装vue插件

python -m SimpleHTTPServer 连接代理服务器

前端学习：

1..html 只需要修改.js, id 引用

Prototype：用来显示已编辑网页
Pages ：用来命名
Modules：连接后端js，具体页面实施


支付方式总结：
无法使用暂时：4

使用方式1，5
1、5测试方法，进入猩便利app，然后点充值有礼，选择金额，选择付款方式
对应的就是第1和第5折两种方法。

5支付宝网站支付；
支付宝app扫码支付，苹果手机不行，必须安卓手机沙箱版才可以支付

无法使用暂时：7
7余额支付。任意扫码充值选择，暂时无法充值。

暂时无法使用：8、9
特殊支付方式一栏。

2.微信扫码
10.微信小程序（我没有授权，所以直接是第2种，不是第10种）
加完权限后就是第10种不是第2种。

3、6
微信-app 支付宝-app
通过猩便利扫码进入然后选择商品支付

沙箱支付宝

oos项目：

配置pay-oss-web中的ftl文件，然后把
src="http://localhost:8000/dist/static/manifest.js"

调试dist目录
http://localhost:8000/dist/

然后去写

去除已经在运行的oss进程：
ps -ef|grep python
kill -9 1462


popover弹出框

div布局，
如何更好地调试，
如何查看语法
前端数据保存周期？传输后端？
console控制台用法？
http post get


<div>
  <div>
  </div>
</div>


盒子模型


1.同样微信支付 app进入 猩便利app进入 不一样？
微信中打开商户的H5页面，商户在H5页面通过调用微信支付提供的JSAPI接口调起微信支付模块来完成支付，
适用于在公众号、朋友圈、聊天窗口等微信内完成支付的场景。

APP支付是指商户通过在移动端应用APP中集成开放SDK调起微信支付模块来完成支付。

2.不同数据交互。 时序图 数据流图 （支付状态图。。。。。。。。。）
业务方（前端，后端） 支付中心（前端，后端） 第三方（前端，端）
3.为什么分三大类。pay-gate-alipay-service， pay-gate-wx-services   pay-gate-common-service
4.作业： 两笔支付单都成功，只有一个预付单情况，怎么出现的，我们怎么办？

5.为什么要这么写?
统一收银台接入
https://wiki.owitho.com/pages/viewpage.action?pageId=7984670
收银台后端对接接口
https://wiki.owitho.com/pages/viewpage.action?pageId=7984678

6作业 怎么用，为什么用 appid代码 --我们怎么用

mqbiztag
mqpaynotifybizrespository

标记

调用beta环境地址：
http://paycenter.owitho.intra.im/payModeManage/mainpage

web工程调试：
beta-pay-oss-web jenkins 和 rundeck
app-pay-center 只需要在 jenkins 上发布

上：前端代码优化， 下午，beta上线修改完后端程序上线， 然后修改前端不符合要求的部分，晚上，完成修改beta
环境下上线。


前端左侧 去除查询 新增和删除用两个表数据



把需要新做的页面，整理设计了一下，定义好了三个工程每个工程的内容，后端接口定义，
传参内容等，

新业务加入来， 如何不用改代码。

SELECT ls_pct_prepayorder.prepay_order_no AS apple, ls_pct_payorder.pay_order_no as banana FROM ls_pct_prepayorder INNER JOIN ls_pct_payorder
ON ls_pct_prepayorder.prepay_order_no = ls_pct_payorder.prepay_order_no;




gitlab
先commit push 完本地分支代码， 然后切换到需要merge的主分支代码中， 选择远程我的代码， 点击merge。
然后解决冲突。解决完后再push上去。然后修改部分deploy到maven仓库

页面打断点：！
Sources 左边 localhost：8000  ==> payData.js

参考 thirdPartMoney orderQuery

单条datafix

主要把要修改的内容修改好了，除了接口外的其他两个工程都正式环境上发好了。


{"payContractDTO":{""}}
代码：payContract
改：{"payContractDTO":{"contractCode":"20180418104633310XLS01RTF5KGVEW","status":44,"userUnionId":55,"validStartTime":"anglebaby"}}
改：{"payContractDTO":{"contractCode":"20180418104633310XLS01RTF5KGVEW","status":0}}
改：{"payContractDTO":{"validStartTime":"Sun Apr 01 00:00:00 CST 2018"}}

{"payContractDTO":{"validStartTime":"1522512000000"}}
{"payContractDTO":{"validEndTime":"1527782400000"}}

{"payContractDTO":{"validStartTime":"1522512000000","validEndTime":"1527782400000"}}

{"payContractDTO":{}}

ORDER BY id DESC,

Sun Apr 01 00:00:00 CST 2018
Wed Apr 25 00:00:00 CST 2018

172.19.152.253:2181

get /DP/SERVER/http:^^service.owitho.com^paycenter^payMiniProgramWXGateService_1.0.0

get /DP/SERVER/http:^^service.owitho.com^paycenter^payModeManageService_1.0.0

set /DP/SERVER/http:^^service.owitho.com^paycenter^contractQueryService_1.0.0 172.19.24.117:4000

zk删除步骤：
查看zk路径：
1.cd
2.cat appenv
3.找到zk地址：zkserver=172.19.152.253:2181
exit退出；
1.找到neo所在目录；
2.进入./neo ssh -e beta -t 172.19.152.253
3.进入zk所在操作目录：cd /app/zookeeper/bin
4.ls
5.zkCli.sh
6.get /DP/SERVER/http:^^service.owitho.com^paycenter^payMiniProgramWXGateService_1.0.0
7.set /DP/SERVER/http:^^service.owitho.com^paycenter^prepayOrderService_1.0.0, 172.19.24.117:4000
8.172.19.24.117:4000是我们本地的zk

//./neo ssh -e prod -t 10.0.30.248

三个工程
权限控制等工作
条件筛选，查看所有签约列表， 条件筛选，web工程， service工程， 前端工程。 + 分页

如何调第三方数据文档看了一下。滤清楚思路，调第三方接口程序，今天写完，然后接入前端，对比数据。

offical:
{"contractCode":"20180428090820637XBL04BCGGDYTF2","contractType":""}
beta:
  {"contractCode":"20180420163630787XLS01R4D0FN7T2","contractType":""}
综合：
{"contractCode":"20180428090820637XBL04BCGGDYTF2","contractType":""}
{"contractCode":"20180502140100752XBL04L3IJULDQ1","contractType":""}

把调用第三方接口，策略分发，拉数据，接口写完，调完，前端也面处理数据库和第三方交互，然后后端的话，更新第三方数据到数据库的接口。
payContractManageDTO
manage接口测试：
{"payContractManageDTO":{"contractCode":"20180428195736128XBL04T035W05OJ","thirdPartContractNo":"20185228429699999","contractType":10,"userUnionId":999,"status":22,"validTime":""}}

页面对比数据分页写完了，然后做一些优化，调试，修改，检查。

有：1，2, 4, 5
无：tx cat-core

蓝色：
都有

2.web.xml
加抬头

红色以下都有了

3.修改
有的会跳


248


https://paycenter.owitho.com/payContract/mainpage

权限匹配：
beta环境：http://my.owitho.intra.im/
线上环境：https://my.owitho.com/

select r.name, concat(p.prefix, '_', p.module,":",p.operation,":",p.value) as permission

boolean isxxxx = SecurityUtils.getSubject().isPermitted("paycenter_operate:all:");
不是
boolean isxxxxx = SecurityUtils.getSubject().isPermitted("paycenter_operate_all:");

https://static.qa.xingbianli.cn/app/app-pay-center/44c1b29bd2612ddd8ad747259adebb92.png


圣哥小技巧总结：
进入状态，打开控制器，查看接口GetSomeoneDoingList.do ---> XHR

https://www.bejson.com/ 在线JSON校验格式化工具

@RestController
注解相当于@ResponseBody ＋ @Controller合在一起的作用
@RestController注解，相当于@Controller+@ResponseBody两个注解的结合，
返回json数据不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，
就不能返回jsp,html页面，视图解析器无法解析jsp,html页面


aop代码 exception 拦截器 熟悉了一下用法， callbackservice错误分析，然后研究了一下。

【LogScan报警】
【主机名】: pay-gate-service-3.sv.prod.alsh.xingbianli.com(10.0.31.76)
【路径】: /data/applogs/pay-gate-service/paygate/abstract_third_paygate_strategy_err_daily.log
【规则】: ERROR:\(payGate\)
【匹配次数】: 1次 / 3min(阈值[1])
【报警时间】: 2018-05-09 14:30:59
【Last line】: [2018-05-09 14:30:03] (FAILURE)ERROR:(payGate) pay gate fail ,req = {"payOrderNo":"20180509142957XBL0000000FH2NCUU","payOrderV2Bean":{"bizType":2,"discountMoney":0.00,"expireTime":900,"payChannel":2,"payMethod":67,"payOrderId":26032092,"paySubject":"猩便利-商品支付","prepayOrderNo":"20180509142955XBL0000000FHYHOD1","returnUrl":"https://h5.xingbianli.com/app/app-openrack-h5/main.html#/order/XBL0000000EVJGMQ6","subjectBody":"[{\"goodsName\":\"脉动维生素饮料青柠味600ml\",\"goodsNum\":1,\"goodsPrice\":6.00}]","thirdPartMoney":6.00,"totalPayMoney":6.00,"tradeNo":"20180509142957XBL0000000FH2NCUU","userId":4193838,"userIp":"112.65.48.232"}} (com.lingshou.pay.cashier.paychannel.strategy.AbstractGatewayV2Strategy.payGate(AbstractGatewayV2Strategy.java:90))

报警为免密支付  第三方返回状态是下单成功支付处理中  支付中心应该将该场景订单状态修改为支付中   不应该抛出异常报错  callback错误 修改订单状态
只能从支付中（32）到　支付完成（64）解决方案
修改response处理   cover下单成功支付处理中 这种场景

///////此处酋长手动到数据库把0 改成 32  然后手动模拟调用callback接口，但是由于三张表忘了修一张表(prepayOrder, payOrder, paycenter_order)，
只手动修复了两张表，所以出现以下错误。
///////
【LogScan报警】
【主机名】: pay-cashier-service-1.sv.prod.alsh.xingbianli.com(10.0.30.248)
【路径】: /data/applogs/pay-cashier-service/call_back/call_back_err_daily.log
【规则】: ERROR:\(callBack\)
【匹配次数】: 1次 / 3min(阈值[1])
【报警时间】: 2018-05-09 14:52:26
【Last line】: [2018-05-09 14:51:46] (FAILURE)ERROR:(callBack)third part pay method call back exception, req:{"payCompleteTime":1525847402000,"payOrderNo":"20180509142957XBL0000000FH2NCUU","resultCode":"T","thirdPartOrderId":"2018050921001004170545469778"} (com.lingshou.pay.cashier.callback.service.impl.CallBackServiceImpl.callBackNew(CallBackServiceImpl.java:153))
//////////////

【LogScan报警】
【主机名】: pay-cashier-service-1.sv.prod.alsh.xingbianli.com(10.0.30.248)
【路径】: /data/applogs/pay-cashier-service/notify/notify2biz_err_daily.log
【规则】: ERROR:\(callBack\)
【匹配次数】: 4次 / 3min(阈值[1])
【报警时间】: 2018-05-10 15:58:58
【Last line】: [2018-05-10 15:58:33] (FAILURE)ERROR:(callBack)notify to biz fail,request:{"charset":"UTF-8","type":"POST","soTimeout":5000,"url":"","needBaAuthorith":false,"topic":"topic_pay2biz","contentType":{"charset":"ISO-8859-1","mimeType":"application/x-www-form-urlencoded"},"properties":{"bizType":"2","tradeNo":"20180507141458XBL0000000FH2NC4H","notifyTime":"2018-05-10 15:58:33","sign":"7d527beb4a82cbf4da28fa749928ba9f","thirdPartOrderId":"4200000121201805074734155121","bizOrderId":"24951864","totalFee":"6.00","payMethod":"35","payChannel":"1","partnerId":"100001","thirdPartMoney":"6.00","failDesc":"补数据","outNo":"XBL0000000EUSZC3C","payCenterId":"25990824","payCompleteTime":"2018-05-07 14:15:06","isSuccess":"T"}} (com.lingshou.pay.cashier.callback.respository.NotifyBizRepository.notifyToBiz(NotifyBizRepository.java:78))

【LogScan报警】
【主机名】: pay-cashier-service-1.sv.prod.alsh.xingbianli.com(10.0.30.248)
【路径】: /data/applogs/pay-cashier-service/notify/notify2biz_err_daily.log
【规则】: ERROR:\(callBack\)
【匹配次数】: 4次 / 3min(阈值[1])
【报警时间】: 2018-05-10 16:01:58
【Last line】: [2018-05-10 15:59:13]
(FAILURE)ERROR:(callBack)notify to biz fail,request:{"charset":"UTF-8","type":"POST","soTimeout":5000,"url":"","needBaAuthorith":false,"topic":"topic_pay2biz","contentType":{"charset":"ISO-8859-1","mimeType":"application/x-www-form-urlencoded"},"properties":{"bizType":"2","tradeNo":"20180509142955XBL0000000FHYHOD1","notifyTime":"2018-05-10 15:59:13","sign":"c37e2a83c4216921aa83b8d3a4fc2b98","thirdPartOrderId":"2018050921001004170545469778","bizOrderId":"24986182","totalFee":"6.00","payMethod":"67","payChannel":"2","partnerId":"100001","thirdPartMoney":"6.00","failDesc":"补数据","outNo":"XBL0000000EVJGMQ6","payCenterId":"26032092","payCompleteTime":"2018-05-09 14:30:02","isSuccess":"T"}} (com.lingshou.pay.cashier.callback.respository.NotifyBizRepository.notifyToBiz(NotifyBizRepository.java:78))

报错是修复数据导致的误报，后续会把这个日志去除]]

notify URl报错

日志进入方式：
./neo ssh -e prod -t 10.0.30.248
cd ../
ls -l
cd data
cd applogs
cd pay-cashier-service

zgrep "fail" notify2biz_err_daily.log.2018-05-10.gz


新的类

public class PayContractThirdPartRepository implements ApplicationContextAware, 接口 {

private ApplicationContext applicationContext;

@Override
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
    this.applicationContext = applicationContext;
    }
}

if（stratgyKey.equals(1)) {
  IContractStrategy strategy = (AliPayPayContractQueryStrategyImpl)applicationContext.getBean("aliAppContractStrategy");
}

MOCK数据：
prepay_order_no = "20180514110226XBL0000000FJGJJ4L" ;
pay_order_no = "20180514110237XBL0000000FIJLNNM"

接口测试：
时间戳
{"tradeNo":"20180126104103334XLS0000VCCCFKG"}

{"refundCallBackInDTO":{"refundNo":"20170808151208XBL00000000000MKF","refundCompleteTime":"1501681380000"}}

修复数据：
【LogScan报警】
【主机名】: pay-cashier-service-1.sv.prod.alsh.xingbianli.com(10.0.30.248)
【路径】: /data/applogs/pay-cashier-service/call_back/call_back_err_daily.log
【规则】: ERROR:\(callBack\)
【匹配次数】: 1次 / 3min(阈值[1])
【报警时间】: 2018-05-21 09:43:30
【Last line】: [2018-05-21 09:40:31] (FAILURE)ERROR:(callBack)third part pay method call back exception, req:{"failDesc":"支付成功","payCompleteTime":1526866830000,"payOrderNo":"20180521094024XBL0000000FKRVOCM","resultCode":"T","thirdPartOrderId":"2018052121001004290578991590"} (com.lingshou.pay.cashier.callback.service.impl.CallBackServiceImpl.callBackNew(CallBackServiceImpl.java:153))
UPDATE `ls_pct_payorder` SET `pay_status` = 32 WHERE `pay_order_no` IN ('20180521094024XBL0000000FKRVOCM', '20180521082544XBL0000000FKQFXV8');
UPDATE `ls_pct_prepayorder` SET `pay_status` = 32 WHERE `prepay_order_no` IN ('20180521094022XBL0000000FLQJ11T', '20180521082541XBL0000000FLP2TYJ');
UPDATE `ls_paycenter_order` SET `pay_status` = 32 WHERE `trade_no` IN ('20180521094022XBL0000000FLQJ11T', '20180521082541XBL0000000FLP2TYJ');

./neo ssh-tunnel -e prod -t 10.0.36.57 -p 4080:4080


and update_time >= #{startTime}
and update_time &lt;= #{endTime}

{"tradeNo":"20180521172519XBL0000000FKYY4RC"}

0 0 0/1 * * ?


if(StringUtils.isNotEmpty(payGateV2Context.getAppId())){
        Map<String,String> contextParams = new HashMap<>();
        contextParams.put("appId",payGateV2Context.getAppId());
        contextParams.put("appId",payGateV2Context.getAppId());

        payOrderNewPO.setContextParams(JSON.toJSONString(contextParams));
    }


public String getContexParam() {

  this.getOrderRequest().getTerminalId();

  return contexParam;
}

public void setContexParam(String contexParam) {
  this.contexParam = contexParam;
}

public CreatePrepayOrderReq getOrderRequest() {
  return orderRequest;
}

pay-gate-alipay-service 修改文档：
AliNoPassWordPayBean.java
AuthCodePayRequestBean.java
MaliPaymentGatewayRequestBean.java

MaliPayRepository.java
NoPasswordPayRepository.java
PayAuthCodeAliGateServiceImpl.java


pay-cashier-gate:
ThirdPayGateReq
BuildReqUtils
PrepayOrderPO
PrepayOrderMapper.xml

PayOrderNewPO payOrderNewPO=new PayOrderNewPO();
    payOrderNewPO.setTermisn("1");
    String result=JSONObject.toJSONString(payOrderNewPO);
    PayOrderNewPO newPO = JSONObject.parseObject(result,PayOrderNewPO.class);
    System.out.println(newPO);


    String contextParams = prepayOrderPO.getContextParams();
       JSONObject jsonObject = JSON.parseObject(contextParams);
       if(jsonObject != null) {
           req.setTerminalId(jsonObject.getString("terminalId"));
       }


JSON测试：{"prepayNo":"20180529200807XLS0000000EVVHNKZ", "payModeId":11}


线上打断点：
选Remote
configuration
host: 172.19.24.117 Port:8000
Search sources using module's classpath pay-cashier-service;


alter table ls_pct_prepayorder add context_params varchar(1024) default null;

CREATE TABLE `ls_pct_mq_resend` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `prepay_order_no` varchar(50) DEFAULT NULL COMMENT '预支付订单号',
  `mq_biz_notify_status` int(11) NOT NULL DEFAULT '0' COMMENT '0：未发送消息 10：已发送消息 20：业务方已收到消息',
  `trigger_time` datetime DEFAULT NULL COMMENT '下次重新发送给mq时间',
  `trigger_num` int(11) NOT NULL DEFAULT '0' COMMENT '第几次触发',
  `is_deleted` int(11) NOT NULL DEFAULT '0' COMMENT '是否已删除此条数据',
  `is_valid` int(11) NOT NULL DEFAULT '0' COMMENT '是否为有效发送数据，0为有效，1为无效',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `IX_Trigger_Time` (`trigger_time`),
  KEY `IX_Prepay_Order_No` (`prepay_order_no`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;

java集合类的实现，
多线程的调用

增:{"groupFileMappingManageDTO":{"groupId":25,"fileId":32}}
改：{"groupFileMappingManageDTO":{"id":2, "groupId":44,"fileId":32}}
查询: {"id":1, "groupId":25}
{"fileId":32}

数据库重命名sql语句：
ls_dat_

去除content查询接口：
SqlInfoQueryService

sqlInfo SqlParamInfoPO 两表添加接口：
SqlInfoDevService

fileSqlinfo 两表查询接口
FileSqlInfoQueryService

task四表添加更新接口
EtlTaskManageService

我们怎么做迁移：2周以后，

三个月为一个q的分享 yarn hadoop 纯技术

Postman:组装json格式
http://localhost:8080/datamanage/dbtable/saveSql
Body：
{"sqlContext":"create table","dbNameSelected":19}
Content-type要选   ：application/json

{"sqlContext":"CREATE TABLE `ads.ads_beehive_fee_kpi` (`month_id` varchar(20) DEFAULT NULL,`beehive_id` bigint(20) DEFAULT NULL,`kpi_type` varchar(20) DEFAULT NULL,`kpi_id` bigint(20) DEFAULT NULL,`kpi_name` varchar(20) DEFAULT NULL,`kpi_value` bigint(20) DEFAULT NULL,`etl_insert_time` datetime DEFAULT NULL,KEY `idx_beehive_month_id` (`beehive_id`,`month_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4","dbNameSelected":123}


CREATE TABLE `ods.rack_order__ls_order_order`(
  `id` bigint COMMENT '订单自增ID',
  `view_id` string COMMENT '页面端展示ID',
  `user_id` bigint COMMENT '用户ID',
  `seller_type` bigint COMMENT '0:售货机 1：零售店',
  `seller_id` string COMMENT '售卖机ID/零售店ID',
  `origin_amount` double COMMENT '订单原始金额',
  `actual_amount` double COMMENT '订单实际金额',
  `pay_status` bigint COMMENT '支付状态0 新建 32 待支付 64 支付成功',
  `refund_status` bigint COMMENT '退款状态 0 无退款 1 退款成功-全部 2 退款成功-部分 3 退款失败',
  `pay_complete_time` timestamp COMMENT '支付完成时间',
  `pay_center_id` bigint COMMENT '支付中心订单id',
  `memo` string COMMENT '备注字段',
  `create_source` bigint COMMENT '订单来源',
  `is_visibility` bigint COMMENT '是否可见 0 不可见 1 可见',
  `create_by` string COMMENT '创建者',
  `create_time` timestamp COMMENT '创建时间',
  `update_by` string COMMENT '更新者',
  `update_time` timestamp COMMENT '更新时间',
  `etl_insert_time` timestamp COMMENT 'etl insert time')
COMMENT '订单表'
PARTITIONED BY (
  `pt` string COMMENT '日期分区')
ROW FORMAT SERDE
  'org.apache.hadoop.hive.ql.io.orc.OrcSerde'
STORED AS INPUTFORMAT
  'org.apache.hadoop.hive.ql.io.orc.OrcInputFormat'
OUTPUTFORMAT
  'org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat'


{"sqlContext":"CREATE TABLE `ods.rack_order__ls_order_order`(  `id` bigint COMMENT '订单自增ID',`view_id` string COMMENT '页面端展示ID',  `user_id` bigint COMMENT '用户ID', `seller_type` bigint COMMENT '0:售货机 1：零售店',`seller_id` string COMMENT '售卖机ID/零售店ID',     `origin_amount` double COMMENT '订单原始金额', `actual_amount` double COMMENT '订单实际金额', `pay_status` bigint COMMENT '支付状态0 新建 32 待支付 64 支付成功', `refund_status` bigint COMMENT '退款状态 0 无退款 1 退款成功-全部 2 退款成功-部分 3 退款失败', `pay_complete_time` timestamp COMMENT '支付完成时间',  `pay_center_id` bigint COMMENT '支付中心订单id', `memo` string COMMENT '备注字段', `create_source` bigint COMMENT '订单来源', `is_visibility` bigint COMMENT '是否可见 0 不可见 1 可见', `create_by` string COMMENT '创建者', `create_time` timestamp COMMENT '创建时间', `update_by` string COMMENT '更新者', `update_time` timestamp COMMENT '更新时间',   `etl_insert_time` timestamp COMMENT 'etl insert time') COMMENT '订单表' PARTITIONED BY ( `pt` string COMMENT '日期分区') ROW FORMAT SERDE    'org.apache.hadoop.hive.ql.io.orc.OrcSerde' STORED AS INPUTFORMAT 'org.apache.hadoop.hive.ql.io.orc.OrcInputFormat'  OUTPUTFORMAT 'org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat'", "dbNameSelected":"ods"}

远程断点：
选remote，
Host：172.19.25.15
Port：8000
bigdata-base=servcie

{"sqlContext":"CREATE TABLE `ods.rack_order__ls_order_order`(  `id` bigint COMMENT '订单自增ID',`view_id` string COMMENT '页面端展示ID',  `user_id` bigint COMMENT '用户ID', `seller_type` bigint COMMENT '0:售货机 1：零售店',`seller_id` string COMMENT '售卖机ID/零售店ID',     `origin_amount` double COMMENT '订单原始金额', `actual_amount` double COMMENT '订单实际金额', `pay_status` bigint COMMENT '支付状态0 新建 32 待支付 64 支付成功', `refund_status` bigint COMMENT '退款状态 0 无退款 1 退款成功-全部 2 退款成功-部分 3 退款失败', `pay_complete_time` timestamp COMMENT '支付完成时间',  `pay_center_id` bigint COMMENT '支付中心订单id', `memo` string COMMENT '备注字段', `create_source` bigint COMMENT '订单来源', `is_visibility` bigint COMMENT '是否可见 0 不可见 1 可见', `create_by` string COMMENT '创建者', `create_time` timestamp COMMENT '创建时间', `update_by` string COMMENT '更新者', `update_time` timestamp COMMENT '更新时间',   `etl_insert_time` timestamp COMMENT 'etl insert time') COMMENT '订单表' PARTITIONED BY ( `pt` string COMMENT '日期分区') ROW FORMAT SERDE    'org.apache.hadoop.hive.ql.io.orc.OrcSerde' STORED AS INPUTFORMAT 'org.apache.hadoop.hive.ql.io.orc.OrcInputFormat'  OUTPUTFORMAT 'org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat'", "dbNameSelected":"ods"}

事务命令：
在ServiceImpl层方法
@Transactional(rollbackFor =Exception.class)

dao层文件配置：

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"
       default-lazy-init="true">

    <bean class="com.dianping.zebra.dao.mybatis.ZebraMapperScannerConfigurer">
        <property name="basePackage"
                  value="com.lingshou.bigdata.mapper.write"/>
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
    </bean>

    <bean id="dataSource" class="com.dianping.zebra.group.jdbc.GroupDataSource" init-method="init">
        <!-- jdbcRef决定需要访问的库的名字，这里指访问的是test库 -->
        <property name="jdbcRef" value="h_dat_datadev" />
        <!-- 选择使用背后使用哪种数据源，"c3p0"或者"tomcat-jdbc"，可以不配，默认值为"c3p0" -->
        <property name="poolType" value="c3p0" />

        <!-- 选择配置源，默认是remote方式，这里使用的是local方式，意味着配置是本地文件 -->
        <!--<property name="configManagerType" value="local" /> -->

        <property name="maxIdleTime" value="1800" />
        <property name="idleConnectionTestPeriod" value="60" />
        <property name="acquireRetryAttempts" value="3" />
        <property name="acquireRetryDelay" value="300" />
        <property name="maxStatements" value="0" />
        <property name="maxStatementsPerConnection" value="100" />
        <property name="numHelperThreads" value="6" />
        <property name="maxAdministrativeTaskTime" value="5" />
        <property name="preferredTestQuery" value="SELECT 1" />
        <property name="maxPoolSize" value="500"/>
    </bean>

    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="mapperLocations">
            <list>
                <value>classpath*:config/sqlmap/write/*.xml</value>
            </list>
        </property>
        <property name="typeAliasesPackage"
                  value="com.lingshou.pay.cashier.po"/>
        <property name="configLocation" value="classpath:config/mybatis/mybatis-configuration.xml"/>
    </bean>

    <tx:annotation-driven transaction-manager = "transactionManager" />

    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>

</beans>



保存逻辑： 1.先判断sql是否合法
2.拿到dbname table_name （tableId） operation --->查出dbId
3.更新ddl表 情况一：ddl数据库表中无数据 直接插入数据
           情况二： ddl表中已有数据 分类情况一：已执行 -->更新版本，重置审核人 更新状态
                                 分类情况二：未执行 -->不更新版本，重置审核人 更新状态

审核通过逻辑： 1.先根据ddlId去拿数据，先去更新 同步数据，更新ddl表格

select count(*) as countNo,source_id as sourceId from ls_dat_meta_blood_analysis_hierarchy where type = 30 and source_id in (113,264) group by source_id order by countNo desc


v-loading
stripe

代码

store-commodity-service	门店商品服务
store-service	门店综合服务
store-stock-service	门店库存服务
store-data-service

7.12
addAll是传入一个List，将此List中的所有元素加入到当前List中，也就是当前List会增加的元素个数为传入的List的大小
https://zhidao.baidu.com/question/2079751182427721388.html
List<Integer> merchIdList = Optional.ofNullable(categorySkuPOS).orElse(Lists.newArrayList()).stream().map(CategorySkuPO::getMerchId).collect(toList());
List<Integer> list = data.entrySet().stream().map(Entry::getValue).collect(Collectors.toList());
这其中map就是把entry的value值映射出来，最后再用Collectors转成list

去重操作
merchIds = merchIds.stream().distinct().collect(toList());

{"userIds":73,"channel":44,"method":55,"name":"anglebaby","description":"weixin","status":1,"enabled":1}

{"userIds":73}

http://localhost:8080/ajax/attendance/schedule


    <select id="selectByClassIds" resultType="com.lingshou.beehive.attendance.po.AttendanceClassDetailPO">
        select
        <include refid="Base_Column_List"/>
        from beehive_attendance_class_detail
        where valid = 1 and class_id in
        <foreach collection="ids" index="index" item="item" open="(" separator="," close=")">
            #{item}
        </foreach>
    </select>


    private List<ScheduleVO> combineScheduleAndClassDetailDTO(Integer userId, Date date, Integer isToday) {
        List<ScheduleVO> scheduleVOS = new ArrayList<>();
        List<AttendanceScheduleDTO> attendanceScheduleDTOS = attendanceScheduleQueryService.listByUserIdDate(userId, date);
        if(CollectionUtils.isEmpty(attendanceScheduleDTOS)) {
            return null;
        }
        for(AttendanceScheduleDTO attendanceScheduleDTO : attendanceScheduleDTOS) {
            Integer classId = attendanceScheduleDTO.getClassId();
            String seq = attendanceScheduleDTO.getSeq();
            AttendanceClassDetailDTO attendanceClassDetailDTO = attendanceScheduleQueryService.listByClassIdAndSeq(classId, seq);
            if(attendanceClassDetailDTO != null) {
                ScheduleVO scheduleVO = new ScheduleVO();
                scheduleVO.setUserId(userId);
                scheduleVO.setDate(attendanceScheduleDTO.getDate());
                scheduleVO.setStartTime(attendanceClassDetailDTO.getStartTime());
                scheduleVO.setEndTime(attendanceClassDetailDTO.getEndTime());
                scheduleVO.setFoodHours(String.valueOf(attendanceClassDetailDTO.getFoodHours()));
                scheduleVO.setIsToday(isToday);
                scheduleVOS.add(scheduleVO);
            }
        }
        return scheduleVOS;
    }

    82//
    字段 代码重写了一下， 库存简单管理过了一下流程
    查看单门店查询接口+controller service迁移模块后


SELECT * FROM `store_sku_stock_report_data` where `shop_id` =21 and `merch_id` =100 order by `record_date`  DESC
SELECT * FROM kylin_store.`store_sku_stock_report_data` where `shop_id` =21 and `merch_id` =100 order by `record_date`  DESC

SELECT `merch_id`, sum(count), `adjustment_reason`,  `create_time`   FROM `store_sku_stock_optlog` where `shop_id` = 21 AND `merch_id` = 100 group by `create_time`,  `adjustment_reason` order by `create_time` DESC

SELECT * FROM sto_analysis.`store_sku_stock_report_data` where `shop_id` =21 and `merch_id` =100 order by `record_date`  DESC





SELECT  `merch_id`, sum(count), `adjustment_reason`,  `create_time`
FROM `store_sku_stock_optlog`
where `shop_id` = 50 and `merch_id` = 2310 GROUP BY `DATE_FORMAT`(create_time,'YYYY-MM-DD'), `adjustment_reason` ORDER BY `create_time` DESC

store-data SkuStockReportDataServiceImpl.getInsufficientDetail

生产日期 效期 加上去 主档 保质期带过来

production_date

shelf_lift_count
shelfLiftCount


expire_date

1为 生产日期
2为 到期日期



计算在里面计算效期
http://localhost:8080/ajax/commoditymanage/modifyexpiredate


push 其他
